//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 4.13.2
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated from SimpraParser.g4 by ANTLR 4.13.2

// Unreachable code detected
#pragma warning disable 0162
// The variable '...' is assigned but its value is never used
#pragma warning disable 0219
// Missing XML comment for publicly visible type or member '...'
#pragma warning disable 1591
// Ambiguous reference in cref attribute
#pragma warning disable 419

using System;
using System.IO;
using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using DFA = Antlr4.Runtime.Dfa.DFA;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.13.2")]
internal partial class SimpraParser : Parser {
	protected static DFA[] decisionToDFA;
	protected static PredictionContextCache sharedContextCache = new PredictionContextCache();
	public const int
		COMMENT=1, BLOCK_COMMENT=2, BOOLEAN=3, NUMBER=4, PASCALSTRING=5, CSTRING=6, 
		PERCENT=7, ON_OFF=8, WS=9, LET=10, WHEN=11, IF=12, THEN=13, ELSE=14, END=15, 
		RETURN=16, IS=17, IS_NOT=18, IN=19, ANY_IN=20, ALL_IN=21, NOT_IN=22, ANY_NOT_IN=23, 
		ALL_NOT_IN=24, NOT=25, MIN=26, MAX=27, MATCHES=28, LIKE=29, HAS=30, VALUE=31, 
		AND=32, OR=33, EQ=34, PLUS=35, MINUS=36, MULT=37, DIV=38, IDIV=39, LT=40, 
		LE=41, GT=42, GE=43, PLUS_EQ=44, MINUS_EQ=45, LPAREN=46, RPAREN=47, LBRACK=48, 
		RBRACK=49, COMMA=50, DOT=51, IDENTIFIER=52, DIRECTIVE=53, ERROR=54;
	public const int
		RULE_program = 0, RULE_objectref = 1, RULE_exp = 2, RULE_extraWhen = 3, 
		RULE_block = 4, RULE_statement = 5, RULE_extraIf = 6;
	public static readonly string[] ruleNames = {
		"program", "objectref", "exp", "extraWhen", "block", "statement", "extraIf"
	};

	private static readonly string[] _LiteralNames = {
		null, null, null, null, null, null, null, "'%'", null, null, "'let'", 
		"'when'", "'if'", "'then'", "'else'", "'end'", "'return'", "'is'", "'is not'", 
		"'in'", "'any in'", "'all in'", "'not in'", "'any not in'", "'all not in'", 
		"'not'", "'min'", "'max'", "'matches'", "'like'", "'has'", "'value'", 
		"'and'", "'or'", "'='", "'+'", "'-'", "'*'", "'/'", "'//'", "'<'", "'<='", 
		"'>'", "'>='", "'+='", "'-='", "'('", "')'", "'['", "']'", "','", "'.'"
	};
	private static readonly string[] _SymbolicNames = {
		null, "COMMENT", "BLOCK_COMMENT", "BOOLEAN", "NUMBER", "PASCALSTRING", 
		"CSTRING", "PERCENT", "ON_OFF", "WS", "LET", "WHEN", "IF", "THEN", "ELSE", 
		"END", "RETURN", "IS", "IS_NOT", "IN", "ANY_IN", "ALL_IN", "NOT_IN", "ANY_NOT_IN", 
		"ALL_NOT_IN", "NOT", "MIN", "MAX", "MATCHES", "LIKE", "HAS", "VALUE", 
		"AND", "OR", "EQ", "PLUS", "MINUS", "MULT", "DIV", "IDIV", "LT", "LE", 
		"GT", "GE", "PLUS_EQ", "MINUS_EQ", "LPAREN", "RPAREN", "LBRACK", "RBRACK", 
		"COMMA", "DOT", "IDENTIFIER", "DIRECTIVE", "ERROR"
	};
	public static readonly IVocabulary DefaultVocabulary = new Vocabulary(_LiteralNames, _SymbolicNames);

	[NotNull]
	public override IVocabulary Vocabulary
	{
		get
		{
			return DefaultVocabulary;
		}
	}

	public override string GrammarFileName { get { return "SimpraParser.g4"; } }

	public override string[] RuleNames { get { return ruleNames; } }

	public override int[] SerializedAtn { get { return _serializedATN; } }

	static SimpraParser() {
		decisionToDFA = new DFA[_ATN.NumberOfDecisions];
		for (int i = 0; i < _ATN.NumberOfDecisions; i++) {
			decisionToDFA[i] = new DFA(_ATN.GetDecisionState(i), i);
		}
	}

		public SimpraParser(ITokenStream input) : this(input, Console.Out, Console.Error) { }

		public SimpraParser(ITokenStream input, TextWriter output, TextWriter errorOutput)
		: base(input, output, errorOutput)
	{
		Interpreter = new ParserATNSimulator(this, _ATN, decisionToDFA, sharedContextCache);
	}

	public partial class ProgramContext : ParserRuleContext {
		public BlockContext Main;
		public ExpContext Expr;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Eof() { return GetToken(SimpraParser.Eof, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public BlockContext block() {
			return GetRuleContext<BlockContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpContext exp() {
			return GetRuleContext<ExpContext>(0);
		}
		public ProgramContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_program; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.EnterProgram(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.ExitProgram(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISimpraParserVisitor<TResult> typedVisitor = visitor as ISimpraParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitProgram(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ProgramContext program() {
		ProgramContext _localctx = new ProgramContext(Context, State);
		EnterRule(_localctx, 0, RULE_program);
		try {
			State = 18;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,0,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 14;
				_localctx.Main = block();
				State = 15;
				Match(Eof);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 17;
				_localctx.Expr = exp(0);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ObjectrefContext : ParserRuleContext {
		public ObjectrefContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_objectref; } }
	 
		public ObjectrefContext() { }
		public virtual void CopyFrom(ObjectrefContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class IdentifierContext : ObjectrefContext {
		public IToken Identifier;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IDENTIFIER() { return GetToken(SimpraParser.IDENTIFIER, 0); }
		public IdentifierContext(ObjectrefContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.EnterIdentifier(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.ExitIdentifier(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISimpraParserVisitor<TResult> typedVisitor = visitor as ISimpraParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIdentifier(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class MemberAccessContext : ObjectrefContext {
		public ObjectrefContext Object;
		public IToken PropertyName;
		[System.Diagnostics.DebuggerNonUserCode] public ObjectrefContext objectref() {
			return GetRuleContext<ObjectrefContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DOT() { return GetToken(SimpraParser.DOT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IDENTIFIER() { return GetToken(SimpraParser.IDENTIFIER, 0); }
		public MemberAccessContext(ObjectrefContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.EnterMemberAccess(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.ExitMemberAccess(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISimpraParserVisitor<TResult> typedVisitor = visitor as ISimpraParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMemberAccess(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class IndexAccessContext : ObjectrefContext {
		public ObjectrefContext Object;
		public ExpContext Index;
		[System.Diagnostics.DebuggerNonUserCode] public ObjectrefContext objectref() {
			return GetRuleContext<ObjectrefContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LBRACK() { return GetToken(SimpraParser.LBRACK, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RBRACK() { return GetToken(SimpraParser.RBRACK, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpContext exp() {
			return GetRuleContext<ExpContext>(0);
		}
		public IndexAccessContext(ObjectrefContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.EnterIndexAccess(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.ExitIndexAccess(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISimpraParserVisitor<TResult> typedVisitor = visitor as ISimpraParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIndexAccess(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class FunctionCallContext : ObjectrefContext {
		public IToken FunctionName;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(SimpraParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(SimpraParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IDENTIFIER() { return GetToken(SimpraParser.IDENTIFIER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpContext[] exp() {
			return GetRuleContexts<ExpContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpContext exp(int i) {
			return GetRuleContext<ExpContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(SimpraParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(SimpraParser.COMMA, i);
		}
		public FunctionCallContext(ObjectrefContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.EnterFunctionCall(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.ExitFunctionCall(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISimpraParserVisitor<TResult> typedVisitor = visitor as ISimpraParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunctionCall(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ObjectrefContext objectref() {
		return objectref(0);
	}

	private ObjectrefContext objectref(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		ObjectrefContext _localctx = new ObjectrefContext(Context, _parentState);
		ObjectrefContext _prevctx = _localctx;
		int _startState = 2;
		EnterRecursionRule(_localctx, 2, RULE_objectref, _p);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 35;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,3,Context) ) {
			case 1:
				{
				_localctx = new IdentifierContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;

				State = 21;
				((IdentifierContext)_localctx).Identifier = Match(IDENTIFIER);
				}
				break;
			case 2:
				{
				_localctx = new FunctionCallContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 22;
				((FunctionCallContext)_localctx).FunctionName = Match(IDENTIFIER);
				State = 23;
				Match(LPAREN);
				State = 25;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if ((((_la) & ~0x3f) == 0 && ((1L << _la) & 4855546461030520L) != 0)) {
					{
					State = 24;
					exp(0);
					}
				}

				State = 31;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 27;
					Match(COMMA);
					State = 28;
					exp(0);
					}
					}
					State = 33;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 34;
				Match(RPAREN);
				}
				break;
			}
			Context.Stop = TokenStream.LT(-1);
			State = 47;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,5,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					State = 45;
					ErrorHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(TokenStream,4,Context) ) {
					case 1:
						{
						_localctx = new MemberAccessContext(new ObjectrefContext(_parentctx, _parentState));
						((MemberAccessContext)_localctx).Object = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_objectref);
						State = 37;
						if (!(Precpred(Context, 2))) throw new FailedPredicateException(this, "Precpred(Context, 2)");
						{
						State = 38;
						Match(DOT);
						State = 39;
						((MemberAccessContext)_localctx).PropertyName = Match(IDENTIFIER);
						}
						}
						break;
					case 2:
						{
						_localctx = new IndexAccessContext(new ObjectrefContext(_parentctx, _parentState));
						((IndexAccessContext)_localctx).Object = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_objectref);
						State = 40;
						if (!(Precpred(Context, 1))) throw new FailedPredicateException(this, "Precpred(Context, 1)");
						{
						State = 41;
						Match(LBRACK);
						State = 42;
						((IndexAccessContext)_localctx).Index = exp(0);
						State = 43;
						Match(RBRACK);
						}
						}
						break;
					}
					} 
				}
				State = 49;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,5,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class ExpContext : ParserRuleContext {
		public ExpContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_exp; } }
	 
		public ExpContext() { }
		public virtual void CopyFrom(ExpContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class BinaryAndContext : ExpContext {
		public ExpContext Left;
		public ExpContext Right;
		[System.Diagnostics.DebuggerNonUserCode] public ExpContext[] exp() {
			return GetRuleContexts<ExpContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpContext exp(int i) {
			return GetRuleContext<ExpContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AND() { return GetToken(SimpraParser.AND, 0); }
		public BinaryAndContext(ExpContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.EnterBinaryAnd(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.ExitBinaryAnd(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISimpraParserVisitor<TResult> typedVisitor = visitor as ISimpraParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBinaryAnd(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class UnaryContext : ExpContext {
		public ExpContext Expression;
		public IToken Operator;
		[System.Diagnostics.DebuggerNonUserCode] public ExpContext exp() {
			return GetRuleContext<ExpContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOT() { return GetToken(SimpraParser.NOT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MINUS() { return GetToken(SimpraParser.MINUS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PLUS() { return GetToken(SimpraParser.PLUS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PERCENT() { return GetToken(SimpraParser.PERCENT, 0); }
		public UnaryContext(ExpContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.EnterUnary(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.ExitUnary(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISimpraParserVisitor<TResult> typedVisitor = visitor as ISimpraParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUnary(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ChainedComparisonContext : ExpContext {
		public ExpContext Expression;
		public IToken LeftOperator;
		public ExpContext Left;
		public IToken RightOperator;
		public ExpContext Right;
		[System.Diagnostics.DebuggerNonUserCode] public ExpContext[] exp() {
			return GetRuleContexts<ExpContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpContext exp(int i) {
			return GetRuleContext<ExpContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AND() { return GetToken(SimpraParser.AND, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OR() { return GetToken(SimpraParser.OR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] LT() { return GetTokens(SimpraParser.LT); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LT(int i) {
			return GetToken(SimpraParser.LT, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] GT() { return GetTokens(SimpraParser.GT); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode GT(int i) {
			return GetToken(SimpraParser.GT, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] LE() { return GetTokens(SimpraParser.LE); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LE(int i) {
			return GetToken(SimpraParser.LE, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] GE() { return GetTokens(SimpraParser.GE); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode GE(int i) {
			return GetToken(SimpraParser.GE, i);
		}
		public ChainedComparisonContext(ExpContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.EnterChainedComparison(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.ExitChainedComparison(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISimpraParserVisitor<TResult> typedVisitor = visitor as ISimpraParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitChainedComparison(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class CStringContext : ExpContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CSTRING() { return GetToken(SimpraParser.CSTRING, 0); }
		public CStringContext(ExpContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.EnterCString(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.ExitCString(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISimpraParserVisitor<TResult> typedVisitor = visitor as ISimpraParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCString(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class HasValueContext : ExpContext {
		public ExpContext Left;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode HAS() { return GetToken(SimpraParser.HAS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode VALUE() { return GetToken(SimpraParser.VALUE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpContext exp() {
			return GetRuleContext<ExpContext>(0);
		}
		public HasValueContext(ExpContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.EnterHasValue(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.ExitHasValue(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISimpraParserVisitor<TResult> typedVisitor = visitor as ISimpraParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitHasValue(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class PascalStringContext : ExpContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PASCALSTRING() { return GetToken(SimpraParser.PASCALSTRING, 0); }
		public PascalStringContext(ExpContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.EnterPascalString(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.ExitPascalString(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISimpraParserVisitor<TResult> typedVisitor = visitor as ISimpraParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPascalString(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ArrayContext : ExpContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LBRACK() { return GetToken(SimpraParser.LBRACK, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RBRACK() { return GetToken(SimpraParser.RBRACK, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpContext[] exp() {
			return GetRuleContexts<ExpContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpContext exp(int i) {
			return GetRuleContext<ExpContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(SimpraParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(SimpraParser.COMMA, i);
		}
		public ArrayContext(ExpContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.EnterArray(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.ExitArray(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISimpraParserVisitor<TResult> typedVisitor = visitor as ISimpraParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitArray(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ParenthesisContext : ExpContext {
		public ExpContext Expression;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(SimpraParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(SimpraParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpContext exp() {
			return GetRuleContext<ExpContext>(0);
		}
		public ParenthesisContext(ExpContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.EnterParenthesis(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.ExitParenthesis(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISimpraParserVisitor<TResult> typedVisitor = visitor as ISimpraParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitParenthesis(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class WhenContext : ExpContext {
		public ExpContext Condition;
		public ExpContext ExpressionTrue;
		public ExpContext ExpressionFalse;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WHEN() { return GetToken(SimpraParser.WHEN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode THEN() { return GetToken(SimpraParser.THEN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode END() { return GetToken(SimpraParser.END, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpContext[] exp() {
			return GetRuleContexts<ExpContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpContext exp(int i) {
			return GetRuleContext<ExpContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ELSE() { return GetToken(SimpraParser.ELSE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExtraWhenContext[] extraWhen() {
			return GetRuleContexts<ExtraWhenContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExtraWhenContext extraWhen(int i) {
			return GetRuleContext<ExtraWhenContext>(i);
		}
		public WhenContext(ExpContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.EnterWhen(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.ExitWhen(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISimpraParserVisitor<TResult> typedVisitor = visitor as ISimpraParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitWhen(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class NumberContext : ExpContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NUMBER() { return GetToken(SimpraParser.NUMBER, 0); }
		public NumberContext(ExpContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.EnterNumber(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.ExitNumber(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISimpraParserVisitor<TResult> typedVisitor = visitor as ISimpraParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNumber(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class BoolContext : ExpContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BOOLEAN() { return GetToken(SimpraParser.BOOLEAN, 0); }
		public BoolContext(ExpContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.EnterBool(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.ExitBool(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISimpraParserVisitor<TResult> typedVisitor = visitor as ISimpraParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBool(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ComparisonContext : ExpContext {
		public ExpContext Left;
		public IToken Operator;
		public ExpContext Right;
		[System.Diagnostics.DebuggerNonUserCode] public ExpContext[] exp() {
			return GetRuleContexts<ExpContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpContext exp(int i) {
			return GetRuleContext<ExpContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LT() { return GetToken(SimpraParser.LT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode GT() { return GetToken(SimpraParser.GT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LE() { return GetToken(SimpraParser.LE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode GE() { return GetToken(SimpraParser.GE, 0); }
		public ComparisonContext(ExpContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.EnterComparison(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.ExitComparison(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISimpraParserVisitor<TResult> typedVisitor = visitor as ISimpraParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitComparison(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class BinaryOrContext : ExpContext {
		public ExpContext Left;
		public ExpContext Right;
		[System.Diagnostics.DebuggerNonUserCode] public ExpContext[] exp() {
			return GetRuleContexts<ExpContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpContext exp(int i) {
			return GetRuleContext<ExpContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OR() { return GetToken(SimpraParser.OR, 0); }
		public BinaryOrContext(ExpContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.EnterBinaryOr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.ExitBinaryOr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISimpraParserVisitor<TResult> typedVisitor = visitor as ISimpraParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBinaryOr(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class BinaryContext : ExpContext {
		public ExpContext Left;
		public IToken Operator;
		public ExpContext Right;
		[System.Diagnostics.DebuggerNonUserCode] public ExpContext[] exp() {
			return GetRuleContexts<ExpContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpContext exp(int i) {
			return GetRuleContext<ExpContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MULT() { return GetToken(SimpraParser.MULT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IDIV() { return GetToken(SimpraParser.IDIV, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DIV() { return GetToken(SimpraParser.DIV, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PLUS() { return GetToken(SimpraParser.PLUS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MINUS() { return GetToken(SimpraParser.MINUS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MIN() { return GetToken(SimpraParser.MIN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MAX() { return GetToken(SimpraParser.MAX, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IS_NOT() { return GetToken(SimpraParser.IS_NOT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IS() { return GetToken(SimpraParser.IS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOT_IN() { return GetToken(SimpraParser.NOT_IN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ANY_NOT_IN() { return GetToken(SimpraParser.ANY_NOT_IN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ALL_NOT_IN() { return GetToken(SimpraParser.ALL_NOT_IN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IN() { return GetToken(SimpraParser.IN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ANY_IN() { return GetToken(SimpraParser.ANY_IN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ALL_IN() { return GetToken(SimpraParser.ALL_IN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LIKE() { return GetToken(SimpraParser.LIKE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MATCHES() { return GetToken(SimpraParser.MATCHES, 0); }
		public BinaryContext(ExpContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.EnterBinary(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.ExitBinary(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISimpraParserVisitor<TResult> typedVisitor = visitor as ISimpraParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBinary(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ObjectRefContext : ExpContext {
		[System.Diagnostics.DebuggerNonUserCode] public ObjectrefContext objectref() {
			return GetRuleContext<ObjectrefContext>(0);
		}
		public ObjectRefContext(ExpContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.EnterObjectRef(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.ExitObjectRef(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISimpraParserVisitor<TResult> typedVisitor = visitor as ISimpraParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitObjectRef(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExpContext exp() {
		return exp(0);
	}

	private ExpContext exp(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		ExpContext _localctx = new ExpContext(Context, _parentState);
		ExpContext _prevctx = _localctx;
		int _startState = 4;
		EnterRecursionRule(_localctx, 4, RULE_exp, _p);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 89;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case BOOLEAN:
				{
				_localctx = new BoolContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;

				State = 51;
				Match(BOOLEAN);
				}
				break;
			case NUMBER:
				{
				_localctx = new NumberContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 52;
				Match(NUMBER);
				}
				break;
			case CSTRING:
				{
				_localctx = new CStringContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 53;
				Match(CSTRING);
				}
				break;
			case PASCALSTRING:
				{
				_localctx = new PascalStringContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 54;
				Match(PASCALSTRING);
				}
				break;
			case LBRACK:
				{
				_localctx = new ArrayContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 55;
				Match(LBRACK);
				State = 57;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if ((((_la) & ~0x3f) == 0 && ((1L << _la) & 4855546461030520L) != 0)) {
					{
					State = 56;
					exp(0);
					}
				}

				State = 63;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 59;
					Match(COMMA);
					State = 60;
					exp(0);
					}
					}
					State = 65;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 66;
				Match(RBRACK);
				}
				break;
			case IDENTIFIER:
				{
				_localctx = new ObjectRefContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 67;
				objectref(0);
				}
				break;
			case LPAREN:
				{
				_localctx = new ParenthesisContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 68;
				Match(LPAREN);
				State = 69;
				((ParenthesisContext)_localctx).Expression = exp(0);
				State = 70;
				Match(RPAREN);
				}
				break;
			case NOT:
			case PLUS:
			case MINUS:
				{
				_localctx = new UnaryContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 72;
				((UnaryContext)_localctx).Operator = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & 103112769536L) != 0)) ) {
					((UnaryContext)_localctx).Operator = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 73;
				((UnaryContext)_localctx).Expression = exp(12);
				}
				break;
			case WHEN:
				{
				_localctx = new WhenContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 74;
				Match(WHEN);
				State = 75;
				((WhenContext)_localctx).Condition = exp(0);
				State = 76;
				Match(THEN);
				State = 77;
				((WhenContext)_localctx).ExpressionTrue = exp(0);
				State = 81;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==WHEN) {
					{
					{
					State = 78;
					extraWhen();
					}
					}
					State = 83;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				{
				State = 84;
				Match(ELSE);
				State = 85;
				((WhenContext)_localctx).ExpressionFalse = exp(0);
				}
				State = 87;
				Match(END);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			Context.Stop = TokenStream.LT(-1);
			State = 129;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,11,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					State = 127;
					ErrorHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(TokenStream,10,Context) ) {
					case 1:
						{
						_localctx = new BinaryContext(new ExpContext(_parentctx, _parentState));
						((BinaryContext)_localctx).Left = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_exp);
						State = 91;
						if (!(Precpred(Context, 10))) throw new FailedPredicateException(this, "Precpred(Context, 10)");
						State = 92;
						((BinaryContext)_localctx).Operator = TokenStream.LT(1);
						_la = TokenStream.LA(1);
						if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & 962072674304L) != 0)) ) {
							((BinaryContext)_localctx).Operator = ErrorHandler.RecoverInline(this);
						}
						else {
							ErrorHandler.ReportMatch(this);
						    Consume();
						}
						State = 93;
						((BinaryContext)_localctx).Right = exp(11);
						}
						break;
					case 2:
						{
						_localctx = new BinaryContext(new ExpContext(_parentctx, _parentState));
						((BinaryContext)_localctx).Left = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_exp);
						State = 94;
						if (!(Precpred(Context, 9))) throw new FailedPredicateException(this, "Precpred(Context, 9)");
						State = 95;
						((BinaryContext)_localctx).Operator = TokenStream.LT(1);
						_la = TokenStream.LA(1);
						if ( !(_la==PLUS || _la==MINUS) ) {
							((BinaryContext)_localctx).Operator = ErrorHandler.RecoverInline(this);
						}
						else {
							ErrorHandler.ReportMatch(this);
						    Consume();
						}
						State = 96;
						((BinaryContext)_localctx).Right = exp(10);
						}
						break;
					case 3:
						{
						_localctx = new BinaryContext(new ExpContext(_parentctx, _parentState));
						((BinaryContext)_localctx).Left = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_exp);
						State = 97;
						if (!(Precpred(Context, 8))) throw new FailedPredicateException(this, "Precpred(Context, 8)");
						State = 98;
						((BinaryContext)_localctx).Operator = TokenStream.LT(1);
						_la = TokenStream.LA(1);
						if ( !(_la==MIN || _la==MAX) ) {
							((BinaryContext)_localctx).Operator = ErrorHandler.RecoverInline(this);
						}
						else {
							ErrorHandler.ReportMatch(this);
						    Consume();
						}
						State = 99;
						((BinaryContext)_localctx).Right = exp(9);
						}
						break;
					case 4:
						{
						_localctx = new ChainedComparisonContext(new ExpContext(_parentctx, _parentState));
						((ChainedComparisonContext)_localctx).Expression = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_exp);
						State = 100;
						if (!(Precpred(Context, 7))) throw new FailedPredicateException(this, "Precpred(Context, 7)");
						State = 101;
						((ChainedComparisonContext)_localctx).LeftOperator = TokenStream.LT(1);
						_la = TokenStream.LA(1);
						if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & 16492674416640L) != 0)) ) {
							((ChainedComparisonContext)_localctx).LeftOperator = ErrorHandler.RecoverInline(this);
						}
						else {
							ErrorHandler.ReportMatch(this);
						    Consume();
						}
						State = 102;
						((ChainedComparisonContext)_localctx).Left = exp(0);
						State = 103;
						_la = TokenStream.LA(1);
						if ( !(_la==AND || _la==OR) ) {
						ErrorHandler.RecoverInline(this);
						}
						else {
							ErrorHandler.ReportMatch(this);
						    Consume();
						}
						State = 104;
						((ChainedComparisonContext)_localctx).RightOperator = TokenStream.LT(1);
						_la = TokenStream.LA(1);
						if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & 16492674416640L) != 0)) ) {
							((ChainedComparisonContext)_localctx).RightOperator = ErrorHandler.RecoverInline(this);
						}
						else {
							ErrorHandler.ReportMatch(this);
						    Consume();
						}
						State = 105;
						((ChainedComparisonContext)_localctx).Right = exp(8);
						}
						break;
					case 5:
						{
						_localctx = new ComparisonContext(new ExpContext(_parentctx, _parentState));
						((ComparisonContext)_localctx).Left = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_exp);
						State = 107;
						if (!(Precpred(Context, 6))) throw new FailedPredicateException(this, "Precpred(Context, 6)");
						State = 108;
						((ComparisonContext)_localctx).Operator = TokenStream.LT(1);
						_la = TokenStream.LA(1);
						if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & 16492674416640L) != 0)) ) {
							((ComparisonContext)_localctx).Operator = ErrorHandler.RecoverInline(this);
						}
						else {
							ErrorHandler.ReportMatch(this);
						    Consume();
						}
						State = 109;
						((ComparisonContext)_localctx).Right = exp(7);
						}
						break;
					case 6:
						{
						_localctx = new BinaryContext(new ExpContext(_parentctx, _parentState));
						((BinaryContext)_localctx).Left = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_exp);
						State = 110;
						if (!(Precpred(Context, 5))) throw new FailedPredicateException(this, "Precpred(Context, 5)");
						State = 111;
						((BinaryContext)_localctx).Operator = TokenStream.LT(1);
						_la = TokenStream.LA(1);
						if ( !(_la==IS || _la==IS_NOT) ) {
							((BinaryContext)_localctx).Operator = ErrorHandler.RecoverInline(this);
						}
						else {
							ErrorHandler.ReportMatch(this);
						    Consume();
						}
						State = 112;
						((BinaryContext)_localctx).Right = exp(6);
						}
						break;
					case 7:
						{
						_localctx = new BinaryContext(new ExpContext(_parentctx, _parentState));
						((BinaryContext)_localctx).Left = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_exp);
						State = 113;
						if (!(Precpred(Context, 4))) throw new FailedPredicateException(this, "Precpred(Context, 4)");
						State = 114;
						((BinaryContext)_localctx).Operator = TokenStream.LT(1);
						_la = TokenStream.LA(1);
						if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & 838336512L) != 0)) ) {
							((BinaryContext)_localctx).Operator = ErrorHandler.RecoverInline(this);
						}
						else {
							ErrorHandler.ReportMatch(this);
						    Consume();
						}
						State = 115;
						((BinaryContext)_localctx).Right = exp(5);
						}
						break;
					case 8:
						{
						_localctx = new BinaryAndContext(new ExpContext(_parentctx, _parentState));
						((BinaryAndContext)_localctx).Left = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_exp);
						State = 116;
						if (!(Precpred(Context, 3))) throw new FailedPredicateException(this, "Precpred(Context, 3)");
						{
						State = 117;
						Match(AND);
						}
						State = 118;
						((BinaryAndContext)_localctx).Right = exp(4);
						}
						break;
					case 9:
						{
						_localctx = new BinaryOrContext(new ExpContext(_parentctx, _parentState));
						((BinaryOrContext)_localctx).Left = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_exp);
						State = 119;
						if (!(Precpred(Context, 2))) throw new FailedPredicateException(this, "Precpred(Context, 2)");
						{
						State = 120;
						Match(OR);
						}
						State = 121;
						((BinaryOrContext)_localctx).Right = exp(3);
						}
						break;
					case 10:
						{
						_localctx = new HasValueContext(new ExpContext(_parentctx, _parentState));
						((HasValueContext)_localctx).Left = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_exp);
						State = 122;
						if (!(Precpred(Context, 13))) throw new FailedPredicateException(this, "Precpred(Context, 13)");
						State = 123;
						Match(HAS);
						State = 124;
						Match(VALUE);
						}
						break;
					case 11:
						{
						_localctx = new UnaryContext(new ExpContext(_parentctx, _parentState));
						((UnaryContext)_localctx).Expression = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_exp);
						State = 125;
						if (!(Precpred(Context, 11))) throw new FailedPredicateException(this, "Precpred(Context, 11)");
						State = 126;
						((UnaryContext)_localctx).Operator = Match(PERCENT);
						}
						break;
					}
					} 
				}
				State = 131;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,11,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class ExtraWhenContext : ParserRuleContext {
		public ExtraWhenContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_extraWhen; } }
	 
		public ExtraWhenContext() { }
		public virtual void CopyFrom(ExtraWhenContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class ExtraWhenExprContext : ExtraWhenContext {
		public ExpContext Condition;
		public ExpContext ExpressionTrue;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WHEN() { return GetToken(SimpraParser.WHEN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode THEN() { return GetToken(SimpraParser.THEN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpContext[] exp() {
			return GetRuleContexts<ExpContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpContext exp(int i) {
			return GetRuleContext<ExpContext>(i);
		}
		public ExtraWhenExprContext(ExtraWhenContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.EnterExtraWhenExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.ExitExtraWhenExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISimpraParserVisitor<TResult> typedVisitor = visitor as ISimpraParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExtraWhenExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExtraWhenContext extraWhen() {
		ExtraWhenContext _localctx = new ExtraWhenContext(Context, State);
		EnterRule(_localctx, 6, RULE_extraWhen);
		try {
			_localctx = new ExtraWhenExprContext(_localctx);
			EnterOuterAlt(_localctx, 1);
			{
			State = 132;
			Match(WHEN);
			State = 133;
			((ExtraWhenExprContext)_localctx).Condition = exp(0);
			State = 134;
			Match(THEN);
			State = 135;
			((ExtraWhenExprContext)_localctx).ExpressionTrue = exp(0);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BlockContext : ParserRuleContext {
		public BlockContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_block; } }
	 
		public BlockContext() { }
		public virtual void CopyFrom(BlockContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class StatementBlockContext : BlockContext {
		[System.Diagnostics.DebuggerNonUserCode] public StatementContext[] statement() {
			return GetRuleContexts<StatementContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public StatementContext statement(int i) {
			return GetRuleContext<StatementContext>(i);
		}
		public StatementBlockContext(BlockContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.EnterStatementBlock(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.ExitStatementBlock(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISimpraParserVisitor<TResult> typedVisitor = visitor as ISimpraParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStatementBlock(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public BlockContext block() {
		BlockContext _localctx = new BlockContext(Context, State);
		EnterRule(_localctx, 8, RULE_block);
		try {
			int _alt;
			_localctx = new StatementBlockContext(_localctx);
			EnterOuterAlt(_localctx, 1);
			{
			State = 140;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,12,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 137;
					statement();
					}
					} 
				}
				State = 142;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,12,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StatementContext : ParserRuleContext {
		public StatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_statement; } }
	 
		public StatementContext() { }
		public virtual void CopyFrom(StatementContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class AssignmentContext : StatementContext {
		public ObjectrefContext Left;
		public ExpContext Right;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EQ() { return GetToken(SimpraParser.EQ, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ObjectrefContext objectref() {
			return GetRuleContext<ObjectrefContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpContext exp() {
			return GetRuleContext<ExpContext>(0);
		}
		public AssignmentContext(StatementContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.EnterAssignment(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.ExitAssignment(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISimpraParserVisitor<TResult> typedVisitor = visitor as ISimpraParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAssignment(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Return2Context : StatementContext {
		public ExpContext Value;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RETURN() { return GetToken(SimpraParser.RETURN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpContext exp() {
			return GetRuleContext<ExpContext>(0);
		}
		public Return2Context(StatementContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.EnterReturn2(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.ExitReturn2(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISimpraParserVisitor<TResult> typedVisitor = visitor as ISimpraParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitReturn2(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class BlockCommentContext : StatementContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BLOCK_COMMENT() { return GetToken(SimpraParser.BLOCK_COMMENT, 0); }
		public BlockCommentContext(StatementContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.EnterBlockComment(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.ExitBlockComment(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISimpraParserVisitor<TResult> typedVisitor = visitor as ISimpraParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBlockComment(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class IfElseStatementContext : StatementContext {
		public ExpContext Condition;
		public BlockContext BlockTrue;
		public BlockContext BlockFalse;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IF() { return GetToken(SimpraParser.IF, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode THEN() { return GetToken(SimpraParser.THEN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode END() { return GetToken(SimpraParser.END, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpContext exp() {
			return GetRuleContext<ExpContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public BlockContext[] block() {
			return GetRuleContexts<BlockContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public BlockContext block(int i) {
			return GetRuleContext<BlockContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExtraIfContext[] extraIf() {
			return GetRuleContexts<ExtraIfContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExtraIfContext extraIf(int i) {
			return GetRuleContext<ExtraIfContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ELSE() { return GetToken(SimpraParser.ELSE, 0); }
		public IfElseStatementContext(StatementContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.EnterIfElseStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.ExitIfElseStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISimpraParserVisitor<TResult> typedVisitor = visitor as ISimpraParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIfElseStatement(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class VariableDeclarationContext : StatementContext {
		public IToken Name;
		public ExpContext Right;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LET() { return GetToken(SimpraParser.LET, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EQ() { return GetToken(SimpraParser.EQ, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IDENTIFIER() { return GetToken(SimpraParser.IDENTIFIER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpContext exp() {
			return GetRuleContext<ExpContext>(0);
		}
		public VariableDeclarationContext(StatementContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.EnterVariableDeclaration(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.ExitVariableDeclaration(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISimpraParserVisitor<TResult> typedVisitor = visitor as ISimpraParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitVariableDeclaration(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class LineCommentContext : StatementContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMENT() { return GetToken(SimpraParser.COMMENT, 0); }
		public LineCommentContext(StatementContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.EnterLineComment(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.ExitLineComment(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISimpraParserVisitor<TResult> typedVisitor = visitor as ISimpraParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLineComment(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class CompoundAssignmentContext : StatementContext {
		public ExpContext Left;
		public IToken Operator;
		public ExpContext Right;
		[System.Diagnostics.DebuggerNonUserCode] public ExpContext[] exp() {
			return GetRuleContexts<ExpContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpContext exp(int i) {
			return GetRuleContext<ExpContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PLUS_EQ() { return GetToken(SimpraParser.PLUS_EQ, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MINUS_EQ() { return GetToken(SimpraParser.MINUS_EQ, 0); }
		public CompoundAssignmentContext(StatementContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.EnterCompoundAssignment(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.ExitCompoundAssignment(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISimpraParserVisitor<TResult> typedVisitor = visitor as ISimpraParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCompoundAssignment(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class DirectiveContext : StatementContext {
		public IToken Name;
		public IToken OnOff;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DIRECTIVE() { return GetToken(SimpraParser.DIRECTIVE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ON_OFF() { return GetToken(SimpraParser.ON_OFF, 0); }
		public DirectiveContext(StatementContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.EnterDirective(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.ExitDirective(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISimpraParserVisitor<TResult> typedVisitor = visitor as ISimpraParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDirective(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StatementContext statement() {
		StatementContext _localctx = new StatementContext(Context, State);
		EnterRule(_localctx, 10, RULE_statement);
		int _la;
		try {
			int _alt;
			State = 177;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,15,Context) ) {
			case 1:
				_localctx = new VariableDeclarationContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 143;
				Match(LET);
				State = 144;
				((VariableDeclarationContext)_localctx).Name = Match(IDENTIFIER);
				State = 145;
				Match(EQ);
				State = 146;
				((VariableDeclarationContext)_localctx).Right = exp(0);
				}
				break;
			case 2:
				_localctx = new AssignmentContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 147;
				((AssignmentContext)_localctx).Left = objectref(0);
				State = 148;
				Match(EQ);
				State = 149;
				((AssignmentContext)_localctx).Right = exp(0);
				}
				break;
			case 3:
				_localctx = new Return2Context(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 151;
				Match(RETURN);
				State = 152;
				((Return2Context)_localctx).Value = exp(0);
				}
				break;
			case 4:
				_localctx = new IfElseStatementContext(_localctx);
				EnterOuterAlt(_localctx, 4);
				{
				State = 153;
				Match(IF);
				State = 154;
				((IfElseStatementContext)_localctx).Condition = exp(0);
				State = 155;
				Match(THEN);
				State = 156;
				((IfElseStatementContext)_localctx).BlockTrue = block();
				State = 160;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,13,Context);
				while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
					if ( _alt==1 ) {
						{
						{
						State = 157;
						extraIf();
						}
						} 
					}
					State = 162;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,13,Context);
				}
				State = 165;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==ELSE) {
					{
					State = 163;
					Match(ELSE);
					State = 164;
					((IfElseStatementContext)_localctx).BlockFalse = block();
					}
				}

				State = 167;
				Match(END);
				}
				break;
			case 5:
				_localctx = new CompoundAssignmentContext(_localctx);
				EnterOuterAlt(_localctx, 5);
				{
				State = 169;
				((CompoundAssignmentContext)_localctx).Left = exp(0);
				State = 170;
				((CompoundAssignmentContext)_localctx).Operator = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==PLUS_EQ || _la==MINUS_EQ) ) {
					((CompoundAssignmentContext)_localctx).Operator = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 171;
				((CompoundAssignmentContext)_localctx).Right = exp(0);
				}
				break;
			case 6:
				_localctx = new LineCommentContext(_localctx);
				EnterOuterAlt(_localctx, 6);
				{
				State = 173;
				Match(COMMENT);
				}
				break;
			case 7:
				_localctx = new BlockCommentContext(_localctx);
				EnterOuterAlt(_localctx, 7);
				{
				State = 174;
				Match(BLOCK_COMMENT);
				}
				break;
			case 8:
				_localctx = new DirectiveContext(_localctx);
				EnterOuterAlt(_localctx, 8);
				{
				State = 175;
				((DirectiveContext)_localctx).Name = Match(DIRECTIVE);
				State = 176;
				((DirectiveContext)_localctx).OnOff = Match(ON_OFF);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExtraIfContext : ParserRuleContext {
		public ExtraIfContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_extraIf; } }
	 
		public ExtraIfContext() { }
		public virtual void CopyFrom(ExtraIfContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class ExtraIfExprContext : ExtraIfContext {
		public ExpContext Condition;
		public BlockContext BlockTrue;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IF() { return GetToken(SimpraParser.IF, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode THEN() { return GetToken(SimpraParser.THEN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpContext exp() {
			return GetRuleContext<ExpContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public BlockContext block() {
			return GetRuleContext<BlockContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ELSE() { return GetToken(SimpraParser.ELSE, 0); }
		public ExtraIfExprContext(ExtraIfContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.EnterExtraIfExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.ExitExtraIfExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISimpraParserVisitor<TResult> typedVisitor = visitor as ISimpraParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExtraIfExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExtraIfContext extraIf() {
		ExtraIfContext _localctx = new ExtraIfContext(Context, State);
		EnterRule(_localctx, 12, RULE_extraIf);
		int _la;
		try {
			_localctx = new ExtraIfExprContext(_localctx);
			EnterOuterAlt(_localctx, 1);
			{
			State = 180;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ELSE) {
				{
				State = 179;
				Match(ELSE);
				}
			}

			State = 182;
			Match(IF);
			State = 183;
			((ExtraIfExprContext)_localctx).Condition = exp(0);
			State = 184;
			Match(THEN);
			State = 185;
			((ExtraIfExprContext)_localctx).BlockTrue = block();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public override bool Sempred(RuleContext _localctx, int ruleIndex, int predIndex) {
		switch (ruleIndex) {
		case 1: return objectref_sempred((ObjectrefContext)_localctx, predIndex);
		case 2: return exp_sempred((ExpContext)_localctx, predIndex);
		}
		return true;
	}
	private bool objectref_sempred(ObjectrefContext _localctx, int predIndex) {
		switch (predIndex) {
		case 0: return Precpred(Context, 2);
		case 1: return Precpred(Context, 1);
		}
		return true;
	}
	private bool exp_sempred(ExpContext _localctx, int predIndex) {
		switch (predIndex) {
		case 2: return Precpred(Context, 10);
		case 3: return Precpred(Context, 9);
		case 4: return Precpred(Context, 8);
		case 5: return Precpred(Context, 7);
		case 6: return Precpred(Context, 6);
		case 7: return Precpred(Context, 5);
		case 8: return Precpred(Context, 4);
		case 9: return Precpred(Context, 3);
		case 10: return Precpred(Context, 2);
		case 11: return Precpred(Context, 13);
		case 12: return Precpred(Context, 11);
		}
		return true;
	}

	private static int[] _serializedATN = {
		4,1,54,188,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,6,1,0,
		1,0,1,0,1,0,3,0,19,8,0,1,1,1,1,1,1,1,1,1,1,3,1,26,8,1,1,1,1,1,5,1,30,8,
		1,10,1,12,1,33,9,1,1,1,3,1,36,8,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,5,1,
		46,8,1,10,1,12,1,49,9,1,1,2,1,2,1,2,1,2,1,2,1,2,1,2,3,2,58,8,2,1,2,1,2,
		5,2,62,8,2,10,2,12,2,65,9,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,
		2,1,2,1,2,5,2,80,8,2,10,2,12,2,83,9,2,1,2,1,2,1,2,1,2,1,2,3,2,90,8,2,1,
		2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,
		1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,
		2,5,2,128,8,2,10,2,12,2,131,9,2,1,3,1,3,1,3,1,3,1,3,1,4,5,4,139,8,4,10,
		4,12,4,142,9,4,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,
		1,5,5,5,159,8,5,10,5,12,5,162,9,5,1,5,1,5,3,5,166,8,5,1,5,1,5,1,5,1,5,
		1,5,1,5,1,5,1,5,1,5,1,5,3,5,178,8,5,1,6,3,6,181,8,6,1,6,1,6,1,6,1,6,1,
		6,1,6,0,2,2,4,7,0,2,4,6,8,10,12,0,9,2,0,25,25,35,36,1,0,37,39,1,0,35,36,
		1,0,26,27,1,0,40,43,1,0,32,33,1,0,17,18,2,0,19,24,28,29,1,0,44,45,219,
		0,18,1,0,0,0,2,35,1,0,0,0,4,89,1,0,0,0,6,132,1,0,0,0,8,140,1,0,0,0,10,
		177,1,0,0,0,12,180,1,0,0,0,14,15,3,8,4,0,15,16,5,0,0,1,16,19,1,0,0,0,17,
		19,3,4,2,0,18,14,1,0,0,0,18,17,1,0,0,0,19,1,1,0,0,0,20,21,6,1,-1,0,21,
		36,5,52,0,0,22,23,5,52,0,0,23,25,5,46,0,0,24,26,3,4,2,0,25,24,1,0,0,0,
		25,26,1,0,0,0,26,31,1,0,0,0,27,28,5,50,0,0,28,30,3,4,2,0,29,27,1,0,0,0,
		30,33,1,0,0,0,31,29,1,0,0,0,31,32,1,0,0,0,32,34,1,0,0,0,33,31,1,0,0,0,
		34,36,5,47,0,0,35,20,1,0,0,0,35,22,1,0,0,0,36,47,1,0,0,0,37,38,10,2,0,
		0,38,39,5,51,0,0,39,46,5,52,0,0,40,41,10,1,0,0,41,42,5,48,0,0,42,43,3,
		4,2,0,43,44,5,49,0,0,44,46,1,0,0,0,45,37,1,0,0,0,45,40,1,0,0,0,46,49,1,
		0,0,0,47,45,1,0,0,0,47,48,1,0,0,0,48,3,1,0,0,0,49,47,1,0,0,0,50,51,6,2,
		-1,0,51,90,5,3,0,0,52,90,5,4,0,0,53,90,5,6,0,0,54,90,5,5,0,0,55,57,5,48,
		0,0,56,58,3,4,2,0,57,56,1,0,0,0,57,58,1,0,0,0,58,63,1,0,0,0,59,60,5,50,
		0,0,60,62,3,4,2,0,61,59,1,0,0,0,62,65,1,0,0,0,63,61,1,0,0,0,63,64,1,0,
		0,0,64,66,1,0,0,0,65,63,1,0,0,0,66,90,5,49,0,0,67,90,3,2,1,0,68,69,5,46,
		0,0,69,70,3,4,2,0,70,71,5,47,0,0,71,90,1,0,0,0,72,73,7,0,0,0,73,90,3,4,
		2,12,74,75,5,11,0,0,75,76,3,4,2,0,76,77,5,13,0,0,77,81,3,4,2,0,78,80,3,
		6,3,0,79,78,1,0,0,0,80,83,1,0,0,0,81,79,1,0,0,0,81,82,1,0,0,0,82,84,1,
		0,0,0,83,81,1,0,0,0,84,85,5,14,0,0,85,86,3,4,2,0,86,87,1,0,0,0,87,88,5,
		15,0,0,88,90,1,0,0,0,89,50,1,0,0,0,89,52,1,0,0,0,89,53,1,0,0,0,89,54,1,
		0,0,0,89,55,1,0,0,0,89,67,1,0,0,0,89,68,1,0,0,0,89,72,1,0,0,0,89,74,1,
		0,0,0,90,129,1,0,0,0,91,92,10,10,0,0,92,93,7,1,0,0,93,128,3,4,2,11,94,
		95,10,9,0,0,95,96,7,2,0,0,96,128,3,4,2,10,97,98,10,8,0,0,98,99,7,3,0,0,
		99,128,3,4,2,9,100,101,10,7,0,0,101,102,7,4,0,0,102,103,3,4,2,0,103,104,
		7,5,0,0,104,105,7,4,0,0,105,106,3,4,2,8,106,128,1,0,0,0,107,108,10,6,0,
		0,108,109,7,4,0,0,109,128,3,4,2,7,110,111,10,5,0,0,111,112,7,6,0,0,112,
		128,3,4,2,6,113,114,10,4,0,0,114,115,7,7,0,0,115,128,3,4,2,5,116,117,10,
		3,0,0,117,118,5,32,0,0,118,128,3,4,2,4,119,120,10,2,0,0,120,121,5,33,0,
		0,121,128,3,4,2,3,122,123,10,13,0,0,123,124,5,30,0,0,124,128,5,31,0,0,
		125,126,10,11,0,0,126,128,5,7,0,0,127,91,1,0,0,0,127,94,1,0,0,0,127,97,
		1,0,0,0,127,100,1,0,0,0,127,107,1,0,0,0,127,110,1,0,0,0,127,113,1,0,0,
		0,127,116,1,0,0,0,127,119,1,0,0,0,127,122,1,0,0,0,127,125,1,0,0,0,128,
		131,1,0,0,0,129,127,1,0,0,0,129,130,1,0,0,0,130,5,1,0,0,0,131,129,1,0,
		0,0,132,133,5,11,0,0,133,134,3,4,2,0,134,135,5,13,0,0,135,136,3,4,2,0,
		136,7,1,0,0,0,137,139,3,10,5,0,138,137,1,0,0,0,139,142,1,0,0,0,140,138,
		1,0,0,0,140,141,1,0,0,0,141,9,1,0,0,0,142,140,1,0,0,0,143,144,5,10,0,0,
		144,145,5,52,0,0,145,146,5,34,0,0,146,178,3,4,2,0,147,148,3,2,1,0,148,
		149,5,34,0,0,149,150,3,4,2,0,150,178,1,0,0,0,151,152,5,16,0,0,152,178,
		3,4,2,0,153,154,5,12,0,0,154,155,3,4,2,0,155,156,5,13,0,0,156,160,3,8,
		4,0,157,159,3,12,6,0,158,157,1,0,0,0,159,162,1,0,0,0,160,158,1,0,0,0,160,
		161,1,0,0,0,161,165,1,0,0,0,162,160,1,0,0,0,163,164,5,14,0,0,164,166,3,
		8,4,0,165,163,1,0,0,0,165,166,1,0,0,0,166,167,1,0,0,0,167,168,5,15,0,0,
		168,178,1,0,0,0,169,170,3,4,2,0,170,171,7,8,0,0,171,172,3,4,2,0,172,178,
		1,0,0,0,173,178,5,1,0,0,174,178,5,2,0,0,175,176,5,53,0,0,176,178,5,8,0,
		0,177,143,1,0,0,0,177,147,1,0,0,0,177,151,1,0,0,0,177,153,1,0,0,0,177,
		169,1,0,0,0,177,173,1,0,0,0,177,174,1,0,0,0,177,175,1,0,0,0,178,11,1,0,
		0,0,179,181,5,14,0,0,180,179,1,0,0,0,180,181,1,0,0,0,181,182,1,0,0,0,182,
		183,5,12,0,0,183,184,3,4,2,0,184,185,5,13,0,0,185,186,3,8,4,0,186,13,1,
		0,0,0,17,18,25,31,35,45,47,57,63,81,89,127,129,140,160,165,177,180
	};

	public static readonly ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN);


}
