//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 4.13.2
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated from SimpraParser.g4 by ANTLR 4.13.2

// Unreachable code detected
#pragma warning disable 0162
// The variable '...' is assigned but its value is never used
#pragma warning disable 0219
// Missing XML comment for publicly visible type or member '...'
#pragma warning disable 1591
// Ambiguous reference in cref attribute
#pragma warning disable 419

using System;
using System.IO;
using System.Text;
using System.Diagnostics;
using System.Collections.Generic;
using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using DFA = Antlr4.Runtime.Dfa.DFA;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.13.2")]
internal partial class SimpraParser : Parser {
	protected static DFA[] decisionToDFA;
	protected static PredictionContextCache sharedContextCache = new PredictionContextCache();
	public const int
		COMMENT=1, BLOCK_COMMENT=2, BOOLEAN=3, NUMBER=4, PASCALSTRING=5, CSTRING=6, 
		PERCENT=7, ON_OFF=8, WS=9, LET=10, WHEN=11, IF=12, THEN=13, ELSE=14, END=15, 
		RETURN=16, IS=17, IS_NOT=18, IN=19, ANY_IN=20, ALL_IN=21, NOT_IN=22, ANY_NOT_IN=23, 
		ALL_NOT_IN=24, NOT=25, MIN=26, MAX=27, MATCHES=28, LIKE=29, HAS=30, VALUE=31, 
		AND=32, OR=33, EQ=34, PLUS=35, MINUS=36, MULT=37, DIV=38, IDIV=39, LT=40, 
		LE=41, GT=42, GE=43, PLUS_EQ=44, MINUS_EQ=45, LPAREN=46, RPAREN=47, LBRACK=48, 
		RBRACK=49, COMMA=50, DOT=51, IDENTIFIER=52, DIRECTIVE=53, ERROR=54;
	public const int
		RULE_program = 0, RULE_objectref = 1, RULE_exp = 2, RULE_extraWhen = 3, 
		RULE_block = 4, RULE_statement = 5, RULE_extraIf = 6;
	public static readonly string[] ruleNames = {
		"program", "objectref", "exp", "extraWhen", "block", "statement", "extraIf"
	};

	private static readonly string[] _LiteralNames = {
		null, null, null, null, null, null, null, "'%'", null, null, "'let'", 
		"'when'", "'if'", "'then'", "'else'", "'end'", "'return'", "'is'", "'is not'", 
		"'in'", "'any in'", "'all in'", "'not in'", "'any not in'", "'all not in'", 
		"'not'", "'min'", "'max'", "'matches'", "'like'", "'has'", "'value'", 
		"'and'", "'or'", "'='", "'+'", "'-'", "'*'", "'/'", "'//'", "'<'", "'<='", 
		"'>'", "'>='", "'+='", "'-='", "'('", "')'", "'['", "']'", "','", "'.'"
	};
	private static readonly string[] _SymbolicNames = {
		null, "COMMENT", "BLOCK_COMMENT", "BOOLEAN", "NUMBER", "PASCALSTRING", 
		"CSTRING", "PERCENT", "ON_OFF", "WS", "LET", "WHEN", "IF", "THEN", "ELSE", 
		"END", "RETURN", "IS", "IS_NOT", "IN", "ANY_IN", "ALL_IN", "NOT_IN", "ANY_NOT_IN", 
		"ALL_NOT_IN", "NOT", "MIN", "MAX", "MATCHES", "LIKE", "HAS", "VALUE", 
		"AND", "OR", "EQ", "PLUS", "MINUS", "MULT", "DIV", "IDIV", "LT", "LE", 
		"GT", "GE", "PLUS_EQ", "MINUS_EQ", "LPAREN", "RPAREN", "LBRACK", "RBRACK", 
		"COMMA", "DOT", "IDENTIFIER", "DIRECTIVE", "ERROR"
	};
	public static readonly IVocabulary DefaultVocabulary = new Vocabulary(_LiteralNames, _SymbolicNames);

	[NotNull]
	public override IVocabulary Vocabulary
	{
		get
		{
			return DefaultVocabulary;
		}
	}

	public override string GrammarFileName { get { return "SimpraParser.g4"; } }

	public override string[] RuleNames { get { return ruleNames; } }

	public override int[] SerializedAtn { get { return _serializedATN; } }

	static SimpraParser() {
		decisionToDFA = new DFA[_ATN.NumberOfDecisions];
		for (int i = 0; i < _ATN.NumberOfDecisions; i++) {
			decisionToDFA[i] = new DFA(_ATN.GetDecisionState(i), i);
		}
	}

		public SimpraParser(ITokenStream input) : this(input, Console.Out, Console.Error) { }

		public SimpraParser(ITokenStream input, TextWriter output, TextWriter errorOutput)
		: base(input, output, errorOutput)
	{
		Interpreter = new ParserATNSimulator(this, _ATN, decisionToDFA, sharedContextCache);
	}

	public partial class ProgramContext : ParserRuleContext {
		public BlockContext Main;
		public ExpContext Expr;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Eof() { return GetToken(SimpraParser.Eof, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public BlockContext block() {
			return GetRuleContext<BlockContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpContext exp() {
			return GetRuleContext<ExpContext>(0);
		}
		public ProgramContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_program; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.EnterProgram(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.ExitProgram(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISimpraParserVisitor<TResult> typedVisitor = visitor as ISimpraParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitProgram(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ProgramContext program() {
		ProgramContext _localctx = new ProgramContext(Context, State);
		EnterRule(_localctx, 0, RULE_program);
		try {
			State = 20;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,0,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 14;
				_localctx.Main = block();
				State = 15;
				Match(Eof);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 17;
				_localctx.Expr = exp(0);
				State = 18;
				Match(Eof);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ObjectrefContext : ParserRuleContext {
		public ObjectrefContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_objectref; } }
	 
		public ObjectrefContext() { }
		public virtual void CopyFrom(ObjectrefContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class IdentifierContext : ObjectrefContext {
		public IToken Identifier;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IDENTIFIER() { return GetToken(SimpraParser.IDENTIFIER, 0); }
		public IdentifierContext(ObjectrefContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.EnterIdentifier(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.ExitIdentifier(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISimpraParserVisitor<TResult> typedVisitor = visitor as ISimpraParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIdentifier(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class MemberAccessContext : ObjectrefContext {
		public ObjectrefContext Object;
		public IToken PropertyName;
		[System.Diagnostics.DebuggerNonUserCode] public ObjectrefContext objectref() {
			return GetRuleContext<ObjectrefContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DOT() { return GetToken(SimpraParser.DOT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IDENTIFIER() { return GetToken(SimpraParser.IDENTIFIER, 0); }
		public MemberAccessContext(ObjectrefContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.EnterMemberAccess(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.ExitMemberAccess(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISimpraParserVisitor<TResult> typedVisitor = visitor as ISimpraParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMemberAccess(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class IndexAccessContext : ObjectrefContext {
		public ObjectrefContext Object;
		public ExpContext Index;
		[System.Diagnostics.DebuggerNonUserCode] public ObjectrefContext objectref() {
			return GetRuleContext<ObjectrefContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LBRACK() { return GetToken(SimpraParser.LBRACK, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RBRACK() { return GetToken(SimpraParser.RBRACK, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpContext exp() {
			return GetRuleContext<ExpContext>(0);
		}
		public IndexAccessContext(ObjectrefContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.EnterIndexAccess(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.ExitIndexAccess(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISimpraParserVisitor<TResult> typedVisitor = visitor as ISimpraParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIndexAccess(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class FunctionCallContext : ObjectrefContext {
		public IToken FunctionName;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(SimpraParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(SimpraParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IDENTIFIER() { return GetToken(SimpraParser.IDENTIFIER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpContext[] exp() {
			return GetRuleContexts<ExpContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpContext exp(int i) {
			return GetRuleContext<ExpContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(SimpraParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(SimpraParser.COMMA, i);
		}
		public FunctionCallContext(ObjectrefContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.EnterFunctionCall(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.ExitFunctionCall(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISimpraParserVisitor<TResult> typedVisitor = visitor as ISimpraParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunctionCall(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ObjectrefContext objectref() {
		return objectref(0);
	}

	private ObjectrefContext objectref(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		ObjectrefContext _localctx = new ObjectrefContext(Context, _parentState);
		ObjectrefContext _prevctx = _localctx;
		int _startState = 2;
		EnterRecursionRule(_localctx, 2, RULE_objectref, _p);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 37;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,3,Context) ) {
			case 1:
				{
				_localctx = new IdentifierContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;

				State = 23;
				((IdentifierContext)_localctx).Identifier = Match(IDENTIFIER);
				}
				break;
			case 2:
				{
				_localctx = new FunctionCallContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 24;
				((FunctionCallContext)_localctx).FunctionName = Match(IDENTIFIER);
				State = 25;
				Match(LPAREN);
				State = 27;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if ((((_la) & ~0x3f) == 0 && ((1L << _la) & 4855546461030520L) != 0)) {
					{
					State = 26;
					exp(0);
					}
				}

				State = 33;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 29;
					Match(COMMA);
					State = 30;
					exp(0);
					}
					}
					State = 35;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 36;
				Match(RPAREN);
				}
				break;
			}
			Context.Stop = TokenStream.LT(-1);
			State = 49;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,5,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					State = 47;
					ErrorHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(TokenStream,4,Context) ) {
					case 1:
						{
						_localctx = new MemberAccessContext(new ObjectrefContext(_parentctx, _parentState));
						((MemberAccessContext)_localctx).Object = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_objectref);
						State = 39;
						if (!(Precpred(Context, 2))) throw new FailedPredicateException(this, "Precpred(Context, 2)");
						{
						State = 40;
						Match(DOT);
						State = 41;
						((MemberAccessContext)_localctx).PropertyName = Match(IDENTIFIER);
						}
						}
						break;
					case 2:
						{
						_localctx = new IndexAccessContext(new ObjectrefContext(_parentctx, _parentState));
						((IndexAccessContext)_localctx).Object = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_objectref);
						State = 42;
						if (!(Precpred(Context, 1))) throw new FailedPredicateException(this, "Precpred(Context, 1)");
						{
						State = 43;
						Match(LBRACK);
						State = 44;
						((IndexAccessContext)_localctx).Index = exp(0);
						State = 45;
						Match(RBRACK);
						}
						}
						break;
					}
					} 
				}
				State = 51;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,5,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class ExpContext : ParserRuleContext {
		public ExpContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_exp; } }
	 
		public ExpContext() { }
		public virtual void CopyFrom(ExpContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class BinaryAndContext : ExpContext {
		public ExpContext Left;
		public ExpContext Right;
		[System.Diagnostics.DebuggerNonUserCode] public ExpContext[] exp() {
			return GetRuleContexts<ExpContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpContext exp(int i) {
			return GetRuleContext<ExpContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AND() { return GetToken(SimpraParser.AND, 0); }
		public BinaryAndContext(ExpContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.EnterBinaryAnd(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.ExitBinaryAnd(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISimpraParserVisitor<TResult> typedVisitor = visitor as ISimpraParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBinaryAnd(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class UnaryContext : ExpContext {
		public ExpContext Expression;
		public IToken Operator;
		[System.Diagnostics.DebuggerNonUserCode] public ExpContext exp() {
			return GetRuleContext<ExpContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOT() { return GetToken(SimpraParser.NOT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MINUS() { return GetToken(SimpraParser.MINUS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PLUS() { return GetToken(SimpraParser.PLUS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PERCENT() { return GetToken(SimpraParser.PERCENT, 0); }
		public UnaryContext(ExpContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.EnterUnary(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.ExitUnary(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISimpraParserVisitor<TResult> typedVisitor = visitor as ISimpraParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUnary(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ChainedComparisonContext : ExpContext {
		public ExpContext Expression;
		public IToken LeftOperator;
		public ExpContext Left;
		public IToken RightOperator;
		public ExpContext Right;
		[System.Diagnostics.DebuggerNonUserCode] public ExpContext[] exp() {
			return GetRuleContexts<ExpContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpContext exp(int i) {
			return GetRuleContext<ExpContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AND() { return GetToken(SimpraParser.AND, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OR() { return GetToken(SimpraParser.OR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] LT() { return GetTokens(SimpraParser.LT); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LT(int i) {
			return GetToken(SimpraParser.LT, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] GT() { return GetTokens(SimpraParser.GT); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode GT(int i) {
			return GetToken(SimpraParser.GT, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] LE() { return GetTokens(SimpraParser.LE); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LE(int i) {
			return GetToken(SimpraParser.LE, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] GE() { return GetTokens(SimpraParser.GE); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode GE(int i) {
			return GetToken(SimpraParser.GE, i);
		}
		public ChainedComparisonContext(ExpContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.EnterChainedComparison(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.ExitChainedComparison(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISimpraParserVisitor<TResult> typedVisitor = visitor as ISimpraParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitChainedComparison(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class CStringContext : ExpContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CSTRING() { return GetToken(SimpraParser.CSTRING, 0); }
		public CStringContext(ExpContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.EnterCString(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.ExitCString(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISimpraParserVisitor<TResult> typedVisitor = visitor as ISimpraParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCString(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class HasValueContext : ExpContext {
		public ExpContext Left;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode HAS() { return GetToken(SimpraParser.HAS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode VALUE() { return GetToken(SimpraParser.VALUE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpContext exp() {
			return GetRuleContext<ExpContext>(0);
		}
		public HasValueContext(ExpContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.EnterHasValue(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.ExitHasValue(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISimpraParserVisitor<TResult> typedVisitor = visitor as ISimpraParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitHasValue(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class PascalStringContext : ExpContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PASCALSTRING() { return GetToken(SimpraParser.PASCALSTRING, 0); }
		public PascalStringContext(ExpContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.EnterPascalString(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.ExitPascalString(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISimpraParserVisitor<TResult> typedVisitor = visitor as ISimpraParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPascalString(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ArrayContext : ExpContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LBRACK() { return GetToken(SimpraParser.LBRACK, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RBRACK() { return GetToken(SimpraParser.RBRACK, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpContext[] exp() {
			return GetRuleContexts<ExpContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpContext exp(int i) {
			return GetRuleContext<ExpContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(SimpraParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(SimpraParser.COMMA, i);
		}
		public ArrayContext(ExpContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.EnterArray(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.ExitArray(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISimpraParserVisitor<TResult> typedVisitor = visitor as ISimpraParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitArray(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ParenthesisContext : ExpContext {
		public ExpContext Expression;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(SimpraParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(SimpraParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpContext exp() {
			return GetRuleContext<ExpContext>(0);
		}
		public ParenthesisContext(ExpContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.EnterParenthesis(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.ExitParenthesis(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISimpraParserVisitor<TResult> typedVisitor = visitor as ISimpraParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitParenthesis(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class WhenContext : ExpContext {
		public ExpContext Condition;
		public ExpContext ExpressionTrue;
		public ExpContext ExpressionFalse;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WHEN() { return GetToken(SimpraParser.WHEN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode THEN() { return GetToken(SimpraParser.THEN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode END() { return GetToken(SimpraParser.END, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpContext[] exp() {
			return GetRuleContexts<ExpContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpContext exp(int i) {
			return GetRuleContext<ExpContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ELSE() { return GetToken(SimpraParser.ELSE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExtraWhenContext[] extraWhen() {
			return GetRuleContexts<ExtraWhenContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExtraWhenContext extraWhen(int i) {
			return GetRuleContext<ExtraWhenContext>(i);
		}
		public WhenContext(ExpContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.EnterWhen(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.ExitWhen(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISimpraParserVisitor<TResult> typedVisitor = visitor as ISimpraParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitWhen(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class NumberContext : ExpContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NUMBER() { return GetToken(SimpraParser.NUMBER, 0); }
		public NumberContext(ExpContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.EnterNumber(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.ExitNumber(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISimpraParserVisitor<TResult> typedVisitor = visitor as ISimpraParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNumber(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class BoolContext : ExpContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BOOLEAN() { return GetToken(SimpraParser.BOOLEAN, 0); }
		public BoolContext(ExpContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.EnterBool(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.ExitBool(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISimpraParserVisitor<TResult> typedVisitor = visitor as ISimpraParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBool(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ComparisonContext : ExpContext {
		public ExpContext Left;
		public IToken Operator;
		public ExpContext Right;
		[System.Diagnostics.DebuggerNonUserCode] public ExpContext[] exp() {
			return GetRuleContexts<ExpContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpContext exp(int i) {
			return GetRuleContext<ExpContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LT() { return GetToken(SimpraParser.LT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode GT() { return GetToken(SimpraParser.GT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LE() { return GetToken(SimpraParser.LE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode GE() { return GetToken(SimpraParser.GE, 0); }
		public ComparisonContext(ExpContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.EnterComparison(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.ExitComparison(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISimpraParserVisitor<TResult> typedVisitor = visitor as ISimpraParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitComparison(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class BinaryOrContext : ExpContext {
		public ExpContext Left;
		public ExpContext Right;
		[System.Diagnostics.DebuggerNonUserCode] public ExpContext[] exp() {
			return GetRuleContexts<ExpContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpContext exp(int i) {
			return GetRuleContext<ExpContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OR() { return GetToken(SimpraParser.OR, 0); }
		public BinaryOrContext(ExpContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.EnterBinaryOr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.ExitBinaryOr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISimpraParserVisitor<TResult> typedVisitor = visitor as ISimpraParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBinaryOr(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class BinaryContext : ExpContext {
		public ExpContext Left;
		public IToken Operator;
		public ExpContext Right;
		[System.Diagnostics.DebuggerNonUserCode] public ExpContext[] exp() {
			return GetRuleContexts<ExpContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpContext exp(int i) {
			return GetRuleContext<ExpContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MULT() { return GetToken(SimpraParser.MULT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IDIV() { return GetToken(SimpraParser.IDIV, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DIV() { return GetToken(SimpraParser.DIV, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PLUS() { return GetToken(SimpraParser.PLUS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MINUS() { return GetToken(SimpraParser.MINUS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MIN() { return GetToken(SimpraParser.MIN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MAX() { return GetToken(SimpraParser.MAX, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IS_NOT() { return GetToken(SimpraParser.IS_NOT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IS() { return GetToken(SimpraParser.IS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOT_IN() { return GetToken(SimpraParser.NOT_IN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ANY_NOT_IN() { return GetToken(SimpraParser.ANY_NOT_IN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ALL_NOT_IN() { return GetToken(SimpraParser.ALL_NOT_IN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IN() { return GetToken(SimpraParser.IN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ANY_IN() { return GetToken(SimpraParser.ANY_IN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ALL_IN() { return GetToken(SimpraParser.ALL_IN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LIKE() { return GetToken(SimpraParser.LIKE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MATCHES() { return GetToken(SimpraParser.MATCHES, 0); }
		public BinaryContext(ExpContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.EnterBinary(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.ExitBinary(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISimpraParserVisitor<TResult> typedVisitor = visitor as ISimpraParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBinary(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ObjectRefContext : ExpContext {
		[System.Diagnostics.DebuggerNonUserCode] public ObjectrefContext objectref() {
			return GetRuleContext<ObjectrefContext>(0);
		}
		public ObjectRefContext(ExpContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.EnterObjectRef(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.ExitObjectRef(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISimpraParserVisitor<TResult> typedVisitor = visitor as ISimpraParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitObjectRef(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExpContext exp() {
		return exp(0);
	}

	private ExpContext exp(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		ExpContext _localctx = new ExpContext(Context, _parentState);
		ExpContext _prevctx = _localctx;
		int _startState = 4;
		EnterRecursionRule(_localctx, 4, RULE_exp, _p);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 91;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case BOOLEAN:
				{
				_localctx = new BoolContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;

				State = 53;
				Match(BOOLEAN);
				}
				break;
			case NUMBER:
				{
				_localctx = new NumberContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 54;
				Match(NUMBER);
				}
				break;
			case CSTRING:
				{
				_localctx = new CStringContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 55;
				Match(CSTRING);
				}
				break;
			case PASCALSTRING:
				{
				_localctx = new PascalStringContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 56;
				Match(PASCALSTRING);
				}
				break;
			case LBRACK:
				{
				_localctx = new ArrayContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 57;
				Match(LBRACK);
				State = 59;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if ((((_la) & ~0x3f) == 0 && ((1L << _la) & 4855546461030520L) != 0)) {
					{
					State = 58;
					exp(0);
					}
				}

				State = 65;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 61;
					Match(COMMA);
					State = 62;
					exp(0);
					}
					}
					State = 67;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				State = 68;
				Match(RBRACK);
				}
				break;
			case IDENTIFIER:
				{
				_localctx = new ObjectRefContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 69;
				objectref(0);
				}
				break;
			case LPAREN:
				{
				_localctx = new ParenthesisContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 70;
				Match(LPAREN);
				State = 71;
				((ParenthesisContext)_localctx).Expression = exp(0);
				State = 72;
				Match(RPAREN);
				}
				break;
			case NOT:
			case PLUS:
			case MINUS:
				{
				_localctx = new UnaryContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 74;
				((UnaryContext)_localctx).Operator = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & 103112769536L) != 0)) ) {
					((UnaryContext)_localctx).Operator = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 75;
				((UnaryContext)_localctx).Expression = exp(12);
				}
				break;
			case WHEN:
				{
				_localctx = new WhenContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 76;
				Match(WHEN);
				State = 77;
				((WhenContext)_localctx).Condition = exp(0);
				State = 78;
				Match(THEN);
				State = 79;
				((WhenContext)_localctx).ExpressionTrue = exp(0);
				State = 83;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==WHEN) {
					{
					{
					State = 80;
					extraWhen();
					}
					}
					State = 85;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				{
				State = 86;
				Match(ELSE);
				State = 87;
				((WhenContext)_localctx).ExpressionFalse = exp(0);
				}
				State = 89;
				Match(END);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			Context.Stop = TokenStream.LT(-1);
			State = 131;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,11,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					State = 129;
					ErrorHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(TokenStream,10,Context) ) {
					case 1:
						{
						_localctx = new BinaryContext(new ExpContext(_parentctx, _parentState));
						((BinaryContext)_localctx).Left = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_exp);
						State = 93;
						if (!(Precpred(Context, 10))) throw new FailedPredicateException(this, "Precpred(Context, 10)");
						State = 94;
						((BinaryContext)_localctx).Operator = TokenStream.LT(1);
						_la = TokenStream.LA(1);
						if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & 962072674304L) != 0)) ) {
							((BinaryContext)_localctx).Operator = ErrorHandler.RecoverInline(this);
						}
						else {
							ErrorHandler.ReportMatch(this);
						    Consume();
						}
						State = 95;
						((BinaryContext)_localctx).Right = exp(11);
						}
						break;
					case 2:
						{
						_localctx = new BinaryContext(new ExpContext(_parentctx, _parentState));
						((BinaryContext)_localctx).Left = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_exp);
						State = 96;
						if (!(Precpred(Context, 9))) throw new FailedPredicateException(this, "Precpred(Context, 9)");
						State = 97;
						((BinaryContext)_localctx).Operator = TokenStream.LT(1);
						_la = TokenStream.LA(1);
						if ( !(_la==PLUS || _la==MINUS) ) {
							((BinaryContext)_localctx).Operator = ErrorHandler.RecoverInline(this);
						}
						else {
							ErrorHandler.ReportMatch(this);
						    Consume();
						}
						State = 98;
						((BinaryContext)_localctx).Right = exp(10);
						}
						break;
					case 3:
						{
						_localctx = new BinaryContext(new ExpContext(_parentctx, _parentState));
						((BinaryContext)_localctx).Left = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_exp);
						State = 99;
						if (!(Precpred(Context, 8))) throw new FailedPredicateException(this, "Precpred(Context, 8)");
						State = 100;
						((BinaryContext)_localctx).Operator = TokenStream.LT(1);
						_la = TokenStream.LA(1);
						if ( !(_la==MIN || _la==MAX) ) {
							((BinaryContext)_localctx).Operator = ErrorHandler.RecoverInline(this);
						}
						else {
							ErrorHandler.ReportMatch(this);
						    Consume();
						}
						State = 101;
						((BinaryContext)_localctx).Right = exp(9);
						}
						break;
					case 4:
						{
						_localctx = new ChainedComparisonContext(new ExpContext(_parentctx, _parentState));
						((ChainedComparisonContext)_localctx).Expression = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_exp);
						State = 102;
						if (!(Precpred(Context, 7))) throw new FailedPredicateException(this, "Precpred(Context, 7)");
						State = 103;
						((ChainedComparisonContext)_localctx).LeftOperator = TokenStream.LT(1);
						_la = TokenStream.LA(1);
						if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & 16492674416640L) != 0)) ) {
							((ChainedComparisonContext)_localctx).LeftOperator = ErrorHandler.RecoverInline(this);
						}
						else {
							ErrorHandler.ReportMatch(this);
						    Consume();
						}
						State = 104;
						((ChainedComparisonContext)_localctx).Left = exp(0);
						State = 105;
						_la = TokenStream.LA(1);
						if ( !(_la==AND || _la==OR) ) {
						ErrorHandler.RecoverInline(this);
						}
						else {
							ErrorHandler.ReportMatch(this);
						    Consume();
						}
						State = 106;
						((ChainedComparisonContext)_localctx).RightOperator = TokenStream.LT(1);
						_la = TokenStream.LA(1);
						if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & 16492674416640L) != 0)) ) {
							((ChainedComparisonContext)_localctx).RightOperator = ErrorHandler.RecoverInline(this);
						}
						else {
							ErrorHandler.ReportMatch(this);
						    Consume();
						}
						State = 107;
						((ChainedComparisonContext)_localctx).Right = exp(8);
						}
						break;
					case 5:
						{
						_localctx = new ComparisonContext(new ExpContext(_parentctx, _parentState));
						((ComparisonContext)_localctx).Left = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_exp);
						State = 109;
						if (!(Precpred(Context, 6))) throw new FailedPredicateException(this, "Precpred(Context, 6)");
						State = 110;
						((ComparisonContext)_localctx).Operator = TokenStream.LT(1);
						_la = TokenStream.LA(1);
						if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & 16492674416640L) != 0)) ) {
							((ComparisonContext)_localctx).Operator = ErrorHandler.RecoverInline(this);
						}
						else {
							ErrorHandler.ReportMatch(this);
						    Consume();
						}
						State = 111;
						((ComparisonContext)_localctx).Right = exp(7);
						}
						break;
					case 6:
						{
						_localctx = new BinaryContext(new ExpContext(_parentctx, _parentState));
						((BinaryContext)_localctx).Left = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_exp);
						State = 112;
						if (!(Precpred(Context, 5))) throw new FailedPredicateException(this, "Precpred(Context, 5)");
						State = 113;
						((BinaryContext)_localctx).Operator = TokenStream.LT(1);
						_la = TokenStream.LA(1);
						if ( !(_la==IS || _la==IS_NOT) ) {
							((BinaryContext)_localctx).Operator = ErrorHandler.RecoverInline(this);
						}
						else {
							ErrorHandler.ReportMatch(this);
						    Consume();
						}
						State = 114;
						((BinaryContext)_localctx).Right = exp(6);
						}
						break;
					case 7:
						{
						_localctx = new BinaryContext(new ExpContext(_parentctx, _parentState));
						((BinaryContext)_localctx).Left = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_exp);
						State = 115;
						if (!(Precpred(Context, 4))) throw new FailedPredicateException(this, "Precpred(Context, 4)");
						State = 116;
						((BinaryContext)_localctx).Operator = TokenStream.LT(1);
						_la = TokenStream.LA(1);
						if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & 838336512L) != 0)) ) {
							((BinaryContext)_localctx).Operator = ErrorHandler.RecoverInline(this);
						}
						else {
							ErrorHandler.ReportMatch(this);
						    Consume();
						}
						State = 117;
						((BinaryContext)_localctx).Right = exp(5);
						}
						break;
					case 8:
						{
						_localctx = new BinaryAndContext(new ExpContext(_parentctx, _parentState));
						((BinaryAndContext)_localctx).Left = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_exp);
						State = 118;
						if (!(Precpred(Context, 3))) throw new FailedPredicateException(this, "Precpred(Context, 3)");
						{
						State = 119;
						Match(AND);
						}
						State = 120;
						((BinaryAndContext)_localctx).Right = exp(4);
						}
						break;
					case 9:
						{
						_localctx = new BinaryOrContext(new ExpContext(_parentctx, _parentState));
						((BinaryOrContext)_localctx).Left = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_exp);
						State = 121;
						if (!(Precpred(Context, 2))) throw new FailedPredicateException(this, "Precpred(Context, 2)");
						{
						State = 122;
						Match(OR);
						}
						State = 123;
						((BinaryOrContext)_localctx).Right = exp(3);
						}
						break;
					case 10:
						{
						_localctx = new HasValueContext(new ExpContext(_parentctx, _parentState));
						((HasValueContext)_localctx).Left = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_exp);
						State = 124;
						if (!(Precpred(Context, 13))) throw new FailedPredicateException(this, "Precpred(Context, 13)");
						State = 125;
						Match(HAS);
						State = 126;
						Match(VALUE);
						}
						break;
					case 11:
						{
						_localctx = new UnaryContext(new ExpContext(_parentctx, _parentState));
						((UnaryContext)_localctx).Expression = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_exp);
						State = 127;
						if (!(Precpred(Context, 11))) throw new FailedPredicateException(this, "Precpred(Context, 11)");
						State = 128;
						((UnaryContext)_localctx).Operator = Match(PERCENT);
						}
						break;
					}
					} 
				}
				State = 133;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,11,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class ExtraWhenContext : ParserRuleContext {
		public ExtraWhenContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_extraWhen; } }
	 
		public ExtraWhenContext() { }
		public virtual void CopyFrom(ExtraWhenContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class ExtraWhenExprContext : ExtraWhenContext {
		public ExpContext Condition;
		public ExpContext ExpressionTrue;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WHEN() { return GetToken(SimpraParser.WHEN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode THEN() { return GetToken(SimpraParser.THEN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpContext[] exp() {
			return GetRuleContexts<ExpContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpContext exp(int i) {
			return GetRuleContext<ExpContext>(i);
		}
		public ExtraWhenExprContext(ExtraWhenContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.EnterExtraWhenExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.ExitExtraWhenExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISimpraParserVisitor<TResult> typedVisitor = visitor as ISimpraParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExtraWhenExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExtraWhenContext extraWhen() {
		ExtraWhenContext _localctx = new ExtraWhenContext(Context, State);
		EnterRule(_localctx, 6, RULE_extraWhen);
		try {
			_localctx = new ExtraWhenExprContext(_localctx);
			EnterOuterAlt(_localctx, 1);
			{
			State = 134;
			Match(WHEN);
			State = 135;
			((ExtraWhenExprContext)_localctx).Condition = exp(0);
			State = 136;
			Match(THEN);
			State = 137;
			((ExtraWhenExprContext)_localctx).ExpressionTrue = exp(0);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BlockContext : ParserRuleContext {
		public BlockContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_block; } }
	 
		public BlockContext() { }
		public virtual void CopyFrom(BlockContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class StatementBlockContext : BlockContext {
		[System.Diagnostics.DebuggerNonUserCode] public StatementContext[] statement() {
			return GetRuleContexts<StatementContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public StatementContext statement(int i) {
			return GetRuleContext<StatementContext>(i);
		}
		public StatementBlockContext(BlockContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.EnterStatementBlock(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.ExitStatementBlock(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISimpraParserVisitor<TResult> typedVisitor = visitor as ISimpraParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStatementBlock(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public BlockContext block() {
		BlockContext _localctx = new BlockContext(Context, State);
		EnterRule(_localctx, 8, RULE_block);
		try {
			int _alt;
			_localctx = new StatementBlockContext(_localctx);
			EnterOuterAlt(_localctx, 1);
			{
			State = 142;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,12,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 139;
					statement();
					}
					} 
				}
				State = 144;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,12,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StatementContext : ParserRuleContext {
		public StatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_statement; } }
	 
		public StatementContext() { }
		public virtual void CopyFrom(StatementContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class AssignmentContext : StatementContext {
		public ObjectrefContext Left;
		public ExpContext Right;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EQ() { return GetToken(SimpraParser.EQ, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ObjectrefContext objectref() {
			return GetRuleContext<ObjectrefContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpContext exp() {
			return GetRuleContext<ExpContext>(0);
		}
		public AssignmentContext(StatementContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.EnterAssignment(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.ExitAssignment(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISimpraParserVisitor<TResult> typedVisitor = visitor as ISimpraParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAssignment(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Return2Context : StatementContext {
		public ExpContext Value;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RETURN() { return GetToken(SimpraParser.RETURN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpContext exp() {
			return GetRuleContext<ExpContext>(0);
		}
		public Return2Context(StatementContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.EnterReturn2(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.ExitReturn2(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISimpraParserVisitor<TResult> typedVisitor = visitor as ISimpraParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitReturn2(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class BlockCommentContext : StatementContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BLOCK_COMMENT() { return GetToken(SimpraParser.BLOCK_COMMENT, 0); }
		public BlockCommentContext(StatementContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.EnterBlockComment(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.ExitBlockComment(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISimpraParserVisitor<TResult> typedVisitor = visitor as ISimpraParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBlockComment(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class IfElseStatementContext : StatementContext {
		public ExpContext Condition;
		public BlockContext BlockTrue;
		public BlockContext BlockFalse;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IF() { return GetToken(SimpraParser.IF, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode THEN() { return GetToken(SimpraParser.THEN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode END() { return GetToken(SimpraParser.END, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpContext exp() {
			return GetRuleContext<ExpContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public BlockContext[] block() {
			return GetRuleContexts<BlockContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public BlockContext block(int i) {
			return GetRuleContext<BlockContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExtraIfContext[] extraIf() {
			return GetRuleContexts<ExtraIfContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExtraIfContext extraIf(int i) {
			return GetRuleContext<ExtraIfContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ELSE() { return GetToken(SimpraParser.ELSE, 0); }
		public IfElseStatementContext(StatementContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.EnterIfElseStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.ExitIfElseStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISimpraParserVisitor<TResult> typedVisitor = visitor as ISimpraParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIfElseStatement(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class VariableDeclarationContext : StatementContext {
		public IToken Name;
		public ExpContext Right;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LET() { return GetToken(SimpraParser.LET, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EQ() { return GetToken(SimpraParser.EQ, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IDENTIFIER() { return GetToken(SimpraParser.IDENTIFIER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpContext exp() {
			return GetRuleContext<ExpContext>(0);
		}
		public VariableDeclarationContext(StatementContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.EnterVariableDeclaration(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.ExitVariableDeclaration(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISimpraParserVisitor<TResult> typedVisitor = visitor as ISimpraParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitVariableDeclaration(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class LineCommentContext : StatementContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMENT() { return GetToken(SimpraParser.COMMENT, 0); }
		public LineCommentContext(StatementContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.EnterLineComment(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.ExitLineComment(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISimpraParserVisitor<TResult> typedVisitor = visitor as ISimpraParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLineComment(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class CompoundAssignmentContext : StatementContext {
		public ExpContext Left;
		public IToken Operator;
		public ExpContext Right;
		[System.Diagnostics.DebuggerNonUserCode] public ExpContext[] exp() {
			return GetRuleContexts<ExpContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpContext exp(int i) {
			return GetRuleContext<ExpContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PLUS_EQ() { return GetToken(SimpraParser.PLUS_EQ, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MINUS_EQ() { return GetToken(SimpraParser.MINUS_EQ, 0); }
		public CompoundAssignmentContext(StatementContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.EnterCompoundAssignment(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.ExitCompoundAssignment(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISimpraParserVisitor<TResult> typedVisitor = visitor as ISimpraParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCompoundAssignment(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class DirectiveContext : StatementContext {
		public IToken Name;
		public IToken OnOff;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DIRECTIVE() { return GetToken(SimpraParser.DIRECTIVE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ON_OFF() { return GetToken(SimpraParser.ON_OFF, 0); }
		public DirectiveContext(StatementContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.EnterDirective(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.ExitDirective(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISimpraParserVisitor<TResult> typedVisitor = visitor as ISimpraParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDirective(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StatementContext statement() {
		StatementContext _localctx = new StatementContext(Context, State);
		EnterRule(_localctx, 10, RULE_statement);
		int _la;
		try {
			int _alt;
			State = 179;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,15,Context) ) {
			case 1:
				_localctx = new VariableDeclarationContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 145;
				Match(LET);
				State = 146;
				((VariableDeclarationContext)_localctx).Name = Match(IDENTIFIER);
				State = 147;
				Match(EQ);
				State = 148;
				((VariableDeclarationContext)_localctx).Right = exp(0);
				}
				break;
			case 2:
				_localctx = new AssignmentContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 149;
				((AssignmentContext)_localctx).Left = objectref(0);
				State = 150;
				Match(EQ);
				State = 151;
				((AssignmentContext)_localctx).Right = exp(0);
				}
				break;
			case 3:
				_localctx = new Return2Context(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 153;
				Match(RETURN);
				State = 154;
				((Return2Context)_localctx).Value = exp(0);
				}
				break;
			case 4:
				_localctx = new IfElseStatementContext(_localctx);
				EnterOuterAlt(_localctx, 4);
				{
				State = 155;
				Match(IF);
				State = 156;
				((IfElseStatementContext)_localctx).Condition = exp(0);
				State = 157;
				Match(THEN);
				State = 158;
				((IfElseStatementContext)_localctx).BlockTrue = block();
				State = 162;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,13,Context);
				while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
					if ( _alt==1 ) {
						{
						{
						State = 159;
						extraIf();
						}
						} 
					}
					State = 164;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,13,Context);
				}
				State = 167;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==ELSE) {
					{
					State = 165;
					Match(ELSE);
					State = 166;
					((IfElseStatementContext)_localctx).BlockFalse = block();
					}
				}

				State = 169;
				Match(END);
				}
				break;
			case 5:
				_localctx = new CompoundAssignmentContext(_localctx);
				EnterOuterAlt(_localctx, 5);
				{
				State = 171;
				((CompoundAssignmentContext)_localctx).Left = exp(0);
				State = 172;
				((CompoundAssignmentContext)_localctx).Operator = TokenStream.LT(1);
				_la = TokenStream.LA(1);
				if ( !(_la==PLUS_EQ || _la==MINUS_EQ) ) {
					((CompoundAssignmentContext)_localctx).Operator = ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 173;
				((CompoundAssignmentContext)_localctx).Right = exp(0);
				}
				break;
			case 6:
				_localctx = new LineCommentContext(_localctx);
				EnterOuterAlt(_localctx, 6);
				{
				State = 175;
				Match(COMMENT);
				}
				break;
			case 7:
				_localctx = new BlockCommentContext(_localctx);
				EnterOuterAlt(_localctx, 7);
				{
				State = 176;
				Match(BLOCK_COMMENT);
				}
				break;
			case 8:
				_localctx = new DirectiveContext(_localctx);
				EnterOuterAlt(_localctx, 8);
				{
				State = 177;
				((DirectiveContext)_localctx).Name = Match(DIRECTIVE);
				State = 178;
				((DirectiveContext)_localctx).OnOff = Match(ON_OFF);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExtraIfContext : ParserRuleContext {
		public ExtraIfContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_extraIf; } }
	 
		public ExtraIfContext() { }
		public virtual void CopyFrom(ExtraIfContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class ExtraIfExprContext : ExtraIfContext {
		public ExpContext Condition;
		public BlockContext BlockTrue;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IF() { return GetToken(SimpraParser.IF, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode THEN() { return GetToken(SimpraParser.THEN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpContext exp() {
			return GetRuleContext<ExpContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public BlockContext block() {
			return GetRuleContext<BlockContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ELSE() { return GetToken(SimpraParser.ELSE, 0); }
		public ExtraIfExprContext(ExtraIfContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.EnterExtraIfExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ISimpraParserListener typedListener = listener as ISimpraParserListener;
			if (typedListener != null) typedListener.ExitExtraIfExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISimpraParserVisitor<TResult> typedVisitor = visitor as ISimpraParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExtraIfExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExtraIfContext extraIf() {
		ExtraIfContext _localctx = new ExtraIfContext(Context, State);
		EnterRule(_localctx, 12, RULE_extraIf);
		int _la;
		try {
			_localctx = new ExtraIfExprContext(_localctx);
			EnterOuterAlt(_localctx, 1);
			{
			State = 182;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ELSE) {
				{
				State = 181;
				Match(ELSE);
				}
			}

			State = 184;
			Match(IF);
			State = 185;
			((ExtraIfExprContext)_localctx).Condition = exp(0);
			State = 186;
			Match(THEN);
			State = 187;
			((ExtraIfExprContext)_localctx).BlockTrue = block();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public override bool Sempred(RuleContext _localctx, int ruleIndex, int predIndex) {
		switch (ruleIndex) {
		case 1: return objectref_sempred((ObjectrefContext)_localctx, predIndex);
		case 2: return exp_sempred((ExpContext)_localctx, predIndex);
		}
		return true;
	}
	private bool objectref_sempred(ObjectrefContext _localctx, int predIndex) {
		switch (predIndex) {
		case 0: return Precpred(Context, 2);
		case 1: return Precpred(Context, 1);
		}
		return true;
	}
	private bool exp_sempred(ExpContext _localctx, int predIndex) {
		switch (predIndex) {
		case 2: return Precpred(Context, 10);
		case 3: return Precpred(Context, 9);
		case 4: return Precpred(Context, 8);
		case 5: return Precpred(Context, 7);
		case 6: return Precpred(Context, 6);
		case 7: return Precpred(Context, 5);
		case 8: return Precpred(Context, 4);
		case 9: return Precpred(Context, 3);
		case 10: return Precpred(Context, 2);
		case 11: return Precpred(Context, 13);
		case 12: return Precpred(Context, 11);
		}
		return true;
	}

	private static int[] _serializedATN = {
		4,1,54,190,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,6,1,0,
		1,0,1,0,1,0,1,0,1,0,3,0,21,8,0,1,1,1,1,1,1,1,1,1,1,3,1,28,8,1,1,1,1,1,
		5,1,32,8,1,10,1,12,1,35,9,1,1,1,3,1,38,8,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
		1,1,5,1,48,8,1,10,1,12,1,51,9,1,1,2,1,2,1,2,1,2,1,2,1,2,1,2,3,2,60,8,2,
		1,2,1,2,5,2,64,8,2,10,2,12,2,67,9,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,
		2,1,2,1,2,1,2,1,2,5,2,82,8,2,10,2,12,2,85,9,2,1,2,1,2,1,2,1,2,1,2,3,2,
		92,8,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,
		1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,
		2,1,2,1,2,5,2,130,8,2,10,2,12,2,133,9,2,1,3,1,3,1,3,1,3,1,3,1,4,5,4,141,
		8,4,10,4,12,4,144,9,4,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,
		1,5,1,5,1,5,5,5,161,8,5,10,5,12,5,164,9,5,1,5,1,5,3,5,168,8,5,1,5,1,5,
		1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,3,5,180,8,5,1,6,3,6,183,8,6,1,6,1,6,1,
		6,1,6,1,6,1,6,0,2,2,4,7,0,2,4,6,8,10,12,0,9,2,0,25,25,35,36,1,0,37,39,
		1,0,35,36,1,0,26,27,1,0,40,43,1,0,32,33,1,0,17,18,2,0,19,24,28,29,1,0,
		44,45,221,0,20,1,0,0,0,2,37,1,0,0,0,4,91,1,0,0,0,6,134,1,0,0,0,8,142,1,
		0,0,0,10,179,1,0,0,0,12,182,1,0,0,0,14,15,3,8,4,0,15,16,5,0,0,1,16,21,
		1,0,0,0,17,18,3,4,2,0,18,19,5,0,0,1,19,21,1,0,0,0,20,14,1,0,0,0,20,17,
		1,0,0,0,21,1,1,0,0,0,22,23,6,1,-1,0,23,38,5,52,0,0,24,25,5,52,0,0,25,27,
		5,46,0,0,26,28,3,4,2,0,27,26,1,0,0,0,27,28,1,0,0,0,28,33,1,0,0,0,29,30,
		5,50,0,0,30,32,3,4,2,0,31,29,1,0,0,0,32,35,1,0,0,0,33,31,1,0,0,0,33,34,
		1,0,0,0,34,36,1,0,0,0,35,33,1,0,0,0,36,38,5,47,0,0,37,22,1,0,0,0,37,24,
		1,0,0,0,38,49,1,0,0,0,39,40,10,2,0,0,40,41,5,51,0,0,41,48,5,52,0,0,42,
		43,10,1,0,0,43,44,5,48,0,0,44,45,3,4,2,0,45,46,5,49,0,0,46,48,1,0,0,0,
		47,39,1,0,0,0,47,42,1,0,0,0,48,51,1,0,0,0,49,47,1,0,0,0,49,50,1,0,0,0,
		50,3,1,0,0,0,51,49,1,0,0,0,52,53,6,2,-1,0,53,92,5,3,0,0,54,92,5,4,0,0,
		55,92,5,6,0,0,56,92,5,5,0,0,57,59,5,48,0,0,58,60,3,4,2,0,59,58,1,0,0,0,
		59,60,1,0,0,0,60,65,1,0,0,0,61,62,5,50,0,0,62,64,3,4,2,0,63,61,1,0,0,0,
		64,67,1,0,0,0,65,63,1,0,0,0,65,66,1,0,0,0,66,68,1,0,0,0,67,65,1,0,0,0,
		68,92,5,49,0,0,69,92,3,2,1,0,70,71,5,46,0,0,71,72,3,4,2,0,72,73,5,47,0,
		0,73,92,1,0,0,0,74,75,7,0,0,0,75,92,3,4,2,12,76,77,5,11,0,0,77,78,3,4,
		2,0,78,79,5,13,0,0,79,83,3,4,2,0,80,82,3,6,3,0,81,80,1,0,0,0,82,85,1,0,
		0,0,83,81,1,0,0,0,83,84,1,0,0,0,84,86,1,0,0,0,85,83,1,0,0,0,86,87,5,14,
		0,0,87,88,3,4,2,0,88,89,1,0,0,0,89,90,5,15,0,0,90,92,1,0,0,0,91,52,1,0,
		0,0,91,54,1,0,0,0,91,55,1,0,0,0,91,56,1,0,0,0,91,57,1,0,0,0,91,69,1,0,
		0,0,91,70,1,0,0,0,91,74,1,0,0,0,91,76,1,0,0,0,92,131,1,0,0,0,93,94,10,
		10,0,0,94,95,7,1,0,0,95,130,3,4,2,11,96,97,10,9,0,0,97,98,7,2,0,0,98,130,
		3,4,2,10,99,100,10,8,0,0,100,101,7,3,0,0,101,130,3,4,2,9,102,103,10,7,
		0,0,103,104,7,4,0,0,104,105,3,4,2,0,105,106,7,5,0,0,106,107,7,4,0,0,107,
		108,3,4,2,8,108,130,1,0,0,0,109,110,10,6,0,0,110,111,7,4,0,0,111,130,3,
		4,2,7,112,113,10,5,0,0,113,114,7,6,0,0,114,130,3,4,2,6,115,116,10,4,0,
		0,116,117,7,7,0,0,117,130,3,4,2,5,118,119,10,3,0,0,119,120,5,32,0,0,120,
		130,3,4,2,4,121,122,10,2,0,0,122,123,5,33,0,0,123,130,3,4,2,3,124,125,
		10,13,0,0,125,126,5,30,0,0,126,130,5,31,0,0,127,128,10,11,0,0,128,130,
		5,7,0,0,129,93,1,0,0,0,129,96,1,0,0,0,129,99,1,0,0,0,129,102,1,0,0,0,129,
		109,1,0,0,0,129,112,1,0,0,0,129,115,1,0,0,0,129,118,1,0,0,0,129,121,1,
		0,0,0,129,124,1,0,0,0,129,127,1,0,0,0,130,133,1,0,0,0,131,129,1,0,0,0,
		131,132,1,0,0,0,132,5,1,0,0,0,133,131,1,0,0,0,134,135,5,11,0,0,135,136,
		3,4,2,0,136,137,5,13,0,0,137,138,3,4,2,0,138,7,1,0,0,0,139,141,3,10,5,
		0,140,139,1,0,0,0,141,144,1,0,0,0,142,140,1,0,0,0,142,143,1,0,0,0,143,
		9,1,0,0,0,144,142,1,0,0,0,145,146,5,10,0,0,146,147,5,52,0,0,147,148,5,
		34,0,0,148,180,3,4,2,0,149,150,3,2,1,0,150,151,5,34,0,0,151,152,3,4,2,
		0,152,180,1,0,0,0,153,154,5,16,0,0,154,180,3,4,2,0,155,156,5,12,0,0,156,
		157,3,4,2,0,157,158,5,13,0,0,158,162,3,8,4,0,159,161,3,12,6,0,160,159,
		1,0,0,0,161,164,1,0,0,0,162,160,1,0,0,0,162,163,1,0,0,0,163,167,1,0,0,
		0,164,162,1,0,0,0,165,166,5,14,0,0,166,168,3,8,4,0,167,165,1,0,0,0,167,
		168,1,0,0,0,168,169,1,0,0,0,169,170,5,15,0,0,170,180,1,0,0,0,171,172,3,
		4,2,0,172,173,7,8,0,0,173,174,3,4,2,0,174,180,1,0,0,0,175,180,5,1,0,0,
		176,180,5,2,0,0,177,178,5,53,0,0,178,180,5,8,0,0,179,145,1,0,0,0,179,149,
		1,0,0,0,179,153,1,0,0,0,179,155,1,0,0,0,179,171,1,0,0,0,179,175,1,0,0,
		0,179,176,1,0,0,0,179,177,1,0,0,0,180,11,1,0,0,0,181,183,5,14,0,0,182,
		181,1,0,0,0,182,183,1,0,0,0,183,184,1,0,0,0,184,185,5,12,0,0,185,186,3,
		4,2,0,186,187,5,13,0,0,187,188,3,8,4,0,188,13,1,0,0,0,17,20,27,33,37,47,
		49,59,65,83,91,129,131,142,162,167,179,182
	};

	public static readonly ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN);


}
